/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "check.h"
#include "token.h"

extern UsersIdDB usersIdDatabase;
int global_current_line_approvals = 0;
int global_valability = 2;

int endsWithConfirm(const char* str) {
    const char* confirmStr = "CONFIRM";
    size_t strLen = strlen(str);
    size_t confirmLen = strlen(confirmStr);

    // Check if the string is long enough to contain "CONFIRM" at the end
    if (strLen < confirmLen) {
        return 0; // False
    }

    // Compare the end of the string with "CONFIRM"
    return strcmp(str + strLen - confirmLen, confirmStr) == 0;
}

void delete_confirm(char *token) {
    // Find the substring "CONFIRM"
    char *confirmPosition = strstr(token, "CONFIRM");

    // Check if "CONFIRM" is found in the string
    if (confirmPosition != NULL) {
        // Calculate the length of the part before "CONFIRM"
        size_t prefixLength = confirmPosition - token;

        // Truncate the string at the position of "CONFIRM"
        token[prefixLength] = '\0';
    }
}

int is_in_resources(char* resource){
	for (int i = 0; i < usersIdDatabase.number_of_resources; i++){
		if (strcmp(usersIdDatabase.resources[i], resource) == 0){
			return 1;
		}
	}
	return 0;
}

char **
request_authorization_func_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	result = calloc(ERROR_LENGTH,sizeof(char));

    // Check if argp is in the database
    for (unsigned int i = 0; i < usersIdDatabase.number_of_users; ++i) {
        if (strcmp(argp[0], usersIdDatabase.users[i]) == 0) {
            // User found in the database, generate and return an access token
            char *token = generate_access_token(argp[0]);
            strcpy(result, token);
            free(token); // Remember to free the allocated token after use
			if(usersIdDatabase.number_of_authz_tokens == 0) {
				usersIdDatabase.number_of_authz_tokens++;
				usersIdDatabase.authz_tokens = calloc(usersIdDatabase.number_of_authz_tokens,sizeof(request_authorization));
				usersIdDatabase.authz_tokens[0].client_id = strdup(argp[0]);
				usersIdDatabase.authz_tokens[0].token = strdup(result);	
			}

			for (unsigned int j = 0; j < usersIdDatabase.number_of_authz_tokens; j++){
				if (strcmp(argp[0],usersIdDatabase.authz_tokens[j].client_id) == 0){
					strcpy(usersIdDatabase.authz_tokens[j].token, result);
					break;
				}
				//User not found
				if (j == usersIdDatabase.number_of_authz_tokens - 1){
					usersIdDatabase.authz_tokens = realloc(usersIdDatabase.authz_tokens, (usersIdDatabase.number_of_authz_tokens + 1) * sizeof(request_authorization));
					usersIdDatabase.number_of_authz_tokens++;
					usersIdDatabase.authz_tokens[usersIdDatabase.number_of_authz_tokens - 1].client_id = strdup(argp[0]);
					usersIdDatabase.authz_tokens[usersIdDatabase.number_of_authz_tokens - 1].token = strdup(result);
				}
			}
			// printf("%s %s\n",usersIdDatabase.authz_tokens[0].client_id, usersIdDatabase.authz_tokens[0].token);
			// printf("%s %s\n",usersIdDatabase.authz_tokens[1].client_id, usersIdDatabase.authz_tokens[1].token);
            return &result;
        }
    }

    // User not found in the database
    strcpy(result, "USER_NOT_FOUND");
	printf("USER_NOT_FOUND\n");
    return &result;
}

struct request_access_token *
request_access_token_func_1_svc(struct request_authorization *argp, struct svc_req *rqstp)
{
	static struct request_access_token  result;
	if (endsWithConfirm(argp->token)){
		for(int i = 0; i < usersIdDatabase.number_of_access_tokens; i++){
			//Can be extracted in another function
			if (strcmp(usersIdDatabase.access_token_list[i].client_id, argp->client_id) == 0){
				//memory leak
				char* generated_token = generate_access_token(argp->token);
				delete_confirm(generated_token);

				usersIdDatabase.access_token_list[i].access_token = generated_token;
				usersIdDatabase.access_token_list[i].refresh_token = generate_access_token(usersIdDatabase.access_token_list[i].access_token);
				usersIdDatabase.access_token_list[i].valability = global_valability;

				result.access_token = usersIdDatabase.access_token_list[i].access_token;
				result.refresh_token = usersIdDatabase.access_token_list[i].refresh_token;
				result.validation_time = global_valability;
				strcpy(result.error, "");

				printf("Modified:\n%s %s %s %d\n",usersIdDatabase.access_token_list[i].client_id,usersIdDatabase.access_token_list[i].access_token,usersIdDatabase.access_token_list[i].refresh_token,usersIdDatabase.access_token_list[i].valability);
				return &result;
			}
		}
		char* generated_token = generate_access_token(argp->token);
		delete_confirm(generated_token);

		usersIdDatabase.access_token_list = realloc(usersIdDatabase.access_token_list, (usersIdDatabase.number_of_access_tokens + 1) * sizeof(AccessToken));
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token = generated_token;
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].refresh_token = generate_access_token(usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token);
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].client_id = strdup(argp->client_id);
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].valability = global_valability;

		result.access_token = strdup(usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token);
		result.refresh_token = strdup(usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].refresh_token);
		result.validation_time = global_valability;
		result.error = strdup("");
		printf("Added:\n%s %s %s %d\n",usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].client_id,usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token,usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].refresh_token,usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].valability);
		usersIdDatabase.number_of_access_tokens++;
		return &result;
	} else {
		result.error = strdup("REQUEST_DENIED");
		return &result;
	}
}

char **
validate_delegated_action_func_1_svc(struct validate_delegated_action *argp, struct svc_req *rqstp)
{
	static char * result;
	for (int i = 0; i < usersIdDatabase.number_of_access_tokens; i++){
		if(strcmp(usersIdDatabase.access_token_list[i].access_token, argp->token) == 0) {
			
		}
	}
	result = strdup("PERMISION_DENIED");

	/*
	 * insert server code here
	 */

	return &result;
}

char **
approve_request_token_func_1_svc(char **argp, struct svc_req *rqstp)
{
	if(usersIdDatabase.approvals[global_current_line_approvals][0].name == NULL){
		global_current_line_approvals++;
		return argp;
	}
	static char * result;
	char* signed_token = calloc(SIGNED_TOKEN_LEN, sizeof(char));
	strcpy(signed_token, *argp);
	strcat(signed_token, "CONFIRM");
	usersIdDatabase.signed_tokens_permisions = realloc(usersIdDatabase.signed_tokens_permisions, (usersIdDatabase.number_of_signed_tokens_permisions + 1) * sizeof(SignedTokenPermisions));
	usersIdDatabase.signed_tokens_permisions[usersIdDatabase.number_of_signed_tokens_permisions].token = signed_token;
	usersIdDatabase.signed_tokens_permisions[usersIdDatabase.number_of_signed_tokens_permisions].approvals = usersIdDatabase.approvals[global_current_line_approvals];
	usersIdDatabase.number_of_signed_tokens_permisions++;
	result = strdup(signed_token);
	global_current_line_approvals++;

	for(int i = 0; i < usersIdDatabase.number_of_signed_tokens_permisions; i++){
		printf("%d = %s\n",i,usersIdDatabase.signed_tokens_permisions[i].token);
	}
	return &result;
}
