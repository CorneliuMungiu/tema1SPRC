/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "check.h"
#include "token.h"

extern UsersIdDB usersIdDatabase;
int global_current_line_approvals = 0;

char **
request_authorization_func_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	result = calloc(ERROR_LENGTH,sizeof(char));

    // Check if argp is in the database
    for (unsigned int i = 0; i < usersIdDatabase.number_of_users; ++i) {
        if (strcmp(argp[0], usersIdDatabase.users[i]) == 0) {
            // User found in the database, generate and return an access token
            char *token = generate_access_token(argp[0]);
            strcpy(result, token);
            free(token); // Remember to free the allocated token after use
			if(usersIdDatabase.number_of_authz_tokens == 0) {
				usersIdDatabase.number_of_authz_tokens++;
				usersIdDatabase.authz_tokens = calloc(usersIdDatabase.number_of_authz_tokens,sizeof(request_authorization));
				usersIdDatabase.authz_tokens[0].client_id = strdup(argp[0]);
				usersIdDatabase.authz_tokens[0].token = strdup(result);	
			}

			for (unsigned int j = 0; j < usersIdDatabase.number_of_authz_tokens; j++){
				if (strcmp(argp[0],usersIdDatabase.authz_tokens[j].client_id) == 0){
					strcpy(usersIdDatabase.authz_tokens[j].token, result);
					break;
				}
				//User not found
				if (j == usersIdDatabase.number_of_authz_tokens - 1){
					usersIdDatabase.authz_tokens = realloc(usersIdDatabase.authz_tokens, (usersIdDatabase.number_of_authz_tokens + 1) * sizeof(request_authorization));
					usersIdDatabase.number_of_authz_tokens++;
					usersIdDatabase.authz_tokens[usersIdDatabase.number_of_authz_tokens - 1].client_id = strdup(argp[0]);
					usersIdDatabase.authz_tokens[usersIdDatabase.number_of_authz_tokens - 1].token = strdup(result);
				}
			}
			// printf("%s %s\n",usersIdDatabase.authz_tokens[0].client_id, usersIdDatabase.authz_tokens[0].token);
			// printf("%s %s\n",usersIdDatabase.authz_tokens[1].client_id, usersIdDatabase.authz_tokens[1].token);
            return &result;
        }
    }

    // User not found in the database
    strcpy(result, "USER_NOT_FOUND");
	printf("USER_NOT_FOUND\n");
    return &result;
}

struct request_access_token *
request_access_token_func_1_svc(struct request_authorization *argp, struct svc_req *rqstp)
{
	static struct request_access_token  result;

	/*
	 * insert server code here
	 */

	return &result;
}

char **
validate_delegated_action_func_1_svc(struct validate_delegated_action *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */

	return &result;
}

char **
approve_request_token_func_1_svc(char **argp, struct svc_req *rqstp)
{
	if(usersIdDatabase.approvals[global_current_line_approvals][0].name == NULL){
		global_current_line_approvals++;
		return argp;
	}
	static char * result;
	char* signed_token = calloc(SIGNED_TOKEN_LEN, sizeof(char));
	strcpy(signed_token, *argp);
	strcat(signed_token, "CONFIRM");
	usersIdDatabase.signed_tokens_permisions = realloc(usersIdDatabase.signed_tokens_permisions, (usersIdDatabase.number_of_signed_tokens_permisions + 1) * sizeof(SignedTokenPermisions));
	usersIdDatabase.signed_tokens_permisions[usersIdDatabase.number_of_signed_tokens_permisions].token = signed_token;
	usersIdDatabase.signed_tokens_permisions[usersIdDatabase.number_of_signed_tokens_permisions].approvals = usersIdDatabase.approvals[global_current_line_approvals];
	usersIdDatabase.number_of_signed_tokens_permisions++;
	result = strdup(signed_token);
	global_current_line_approvals++;

	for(int i = 0; i < usersIdDatabase.number_of_signed_tokens_permisions; i++){
		printf("%d = %s\n",i,usersIdDatabase.signed_tokens_permisions[i].token);
	}
	return &result;
}
