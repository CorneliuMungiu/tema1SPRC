/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "check.h"
#include "token.h"

extern UsersIdDB usersIdDatabase;
int global_current_line_approvals = 0;
extern int global_valability;

int endsWithConfirm(const char* str) {
    const char* confirmStr = "CONFIRM";
    size_t strLen = strlen(str);
    size_t confirmLen = strlen(confirmStr);

    if (strLen < confirmLen) {
        return 0;
    }
    return strcmp(str + strLen - confirmLen, confirmStr) == 0;
}

void delete_confirm(char *token) {
    // Find the substring "CONFIRM"
    char *confirmPosition = strstr(token, "CONFIRM");

    // Check if "CONFIRM" is found in the string
    if (confirmPosition != NULL) {
        // Calculate the length of the part before "CONFIRM"
        size_t prefixLength = confirmPosition - token;

        // Truncate the string at the position of "CONFIRM"
        token[prefixLength] = '\0';
    }
}

int is_in_resources(char* resource){
	for (int i = 0; i < usersIdDatabase.number_of_resources; i++){
		if (strcmp(usersIdDatabase.resources[i], resource) == 0){
			return 1;
		}
	}
	return 0;
}

char **
request_authorization_func_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	result = calloc(ERROR_LENGTH,sizeof(char));

    // Check if argp is in the database
    for (unsigned int i = 0; i < usersIdDatabase.number_of_users; ++i) {
        if (strcmp(argp[0], usersIdDatabase.users[i]) == 0) {
            // User found in the database, generate and return an access token
            char *token = generate_access_token(argp[0]);
            strcpy(result, token);
            free(token); // Remember to free the allocated token after use
			if(usersIdDatabase.number_of_authz_tokens == 0) {
				usersIdDatabase.number_of_authz_tokens++;
				usersIdDatabase.authz_tokens = calloc(usersIdDatabase.number_of_authz_tokens,sizeof(request_authorization));
				usersIdDatabase.authz_tokens[0].client_id = strdup(argp[0]);
				usersIdDatabase.authz_tokens[0].token = strdup(result);	
			}

			for (unsigned int j = 0; j < usersIdDatabase.number_of_authz_tokens; j++){
				if (strcmp(argp[0],usersIdDatabase.authz_tokens[j].client_id) == 0){
					strcpy(usersIdDatabase.authz_tokens[j].token, result);
					break;
				}
				//User not found
				if (j == usersIdDatabase.number_of_authz_tokens - 1){
					usersIdDatabase.authz_tokens = realloc(usersIdDatabase.authz_tokens, (usersIdDatabase.number_of_authz_tokens + 1) * sizeof(request_authorization));
					usersIdDatabase.number_of_authz_tokens++;
					usersIdDatabase.authz_tokens[usersIdDatabase.number_of_authz_tokens - 1].client_id = strdup(argp[0]);
					usersIdDatabase.authz_tokens[usersIdDatabase.number_of_authz_tokens - 1].token = strdup(result);
				}
			}
			// printf("%s %s\n",usersIdDatabase.authz_tokens[0].client_id, usersIdDatabase.authz_tokens[0].token);
			// printf("%s %s\n",usersIdDatabase.authz_tokens[1].client_id, usersIdDatabase.authz_tokens[1].token);
            return &result;
        }
    }

    // User not found in the database
    strcpy(result, "USER_NOT_FOUND");
	printf("USER_NOT_FOUND\n");
    return &result;
}

struct request_access_token *
request_access_token_func_1_svc(struct request_authorization *argp, struct svc_req *rqstp)
{
	static struct request_access_token  result;
	printf("=============%s\n",argp->token);
	if (endsWithConfirm(argp->token)){
		for(int i = 0; i < usersIdDatabase.number_of_access_tokens; i++){
			//Can be extracted in another function
			if (strcmp(usersIdDatabase.access_token_list[i].client_id, argp->client_id) == 0){
				//memory leak
				char* generated_token = generate_access_token(argp->token);
				delete_confirm(generated_token);

				usersIdDatabase.access_token_list[i].access_token = generated_token;
				usersIdDatabase.access_token_list[i].valability = global_valability;
				usersIdDatabase.access_token_list[i].auto_refresh = argp->auto_refresh;

				if(argp->auto_refresh == 1){
					usersIdDatabase.access_token_list[i].refresh_token = generate_access_token(usersIdDatabase.access_token_list[i].access_token);
				} else {
					usersIdDatabase.access_token_list[i].refresh_token = strdup("");
				}
				

				result.access_token = usersIdDatabase.access_token_list[i].access_token;
				result.refresh_token = usersIdDatabase.access_token_list[i].refresh_token;
				result.validation_time = global_valability;
				strcpy(result.error, "");

				printf("Modified:\n%s %s %s %d\n",usersIdDatabase.access_token_list[i].client_id,usersIdDatabase.access_token_list[i].access_token,usersIdDatabase.access_token_list[i].refresh_token,usersIdDatabase.access_token_list[i].valability);
				return &result;
			}
		}
		char* generated_token = generate_access_token(argp->token);
		delete_confirm(generated_token);

		usersIdDatabase.access_token_list = realloc(usersIdDatabase.access_token_list, (usersIdDatabase.number_of_access_tokens + 1) * sizeof(AccessToken));
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token = generated_token;
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].client_id = strdup(argp->client_id);
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].valability = global_valability;
		usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].auto_refresh = argp->auto_refresh;

		if(argp->auto_refresh == 1){
			usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].refresh_token = generate_access_token(usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token);
		} else {
			usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].refresh_token = strdup("");
		}

		result.access_token = strdup(usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token);
		result.refresh_token = strdup(usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].refresh_token);
		result.validation_time = global_valability;
		result.error = strdup("");
		printf("Added:\n%s %s %s %d\n",usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].client_id,usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].access_token,usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].refresh_token,usersIdDatabase.access_token_list[usersIdDatabase.number_of_access_tokens].valability);
		usersIdDatabase.number_of_access_tokens++;
		return &result;
	} else {
		result.access_token = strdup("");
		result.refresh_token = strdup("");
		result.validation_time = -1;
		printf("====================================================\n");
		result.error = strdup("REQUEST_DENIED");
		return &result;
	}
}

struct request_access_token* validate_delegated_action_func_1_svc(struct validate_delegated_action *argp, struct svc_req *rqstp)
{
	struct request_access_token* result = calloc(1,sizeof(struct request_access_token));
	for (int i = 0; i < usersIdDatabase.number_of_access_tokens; i++){
		if(strcmp(usersIdDatabase.access_token_list[i].access_token, argp->token) == 0) {
			if(usersIdDatabase.access_token_list[i].valability == 0){
				if(usersIdDatabase.access_token_list[i].auto_refresh == 1){
					//Free memory before the assignation to result
					result->access_token = generate_access_token(usersIdDatabase.access_token_list[i].refresh_token);
					strcpy(usersIdDatabase.access_token_list[i].access_token, result->access_token);
					result->refresh_token = generate_access_token(result->access_token);
					strcpy(usersIdDatabase.access_token_list[i].refresh_token, result->refresh_token);
					usersIdDatabase.access_token_list[i].valability = global_valability;
				} else {
					result->access_token = strdup("");
					result->refresh_token = strdup("");
					result->validation_time = -1;
					result->error = strdup("TOKEN_EXPIRED");
					return result;
				}
				usersIdDatabase.access_token_list[i].valability--;
				if (!is_in_resources(argp->accessed_resource)) {
					result->access_token = strdup("");
					result->refresh_token = strdup("");
					result->validation_time = -1;
					result->error = strdup("RESOURCE_NOT_FOUND");	
					return result;
				}

				if(strcmp(argp->operation_type, "READ") == 0){
					for(int j = 0; j < usersIdDatabase.number_of_approvals_colums; j++){
						if(strcmp(argp->accessed_resource, usersIdDatabase.approvals[global_current_line_approvals][j].name) == 0){
							if(usersIdDatabase.approvals[global_current_line_approvals][j].read == 1){
								result->error = strdup("PERMISSION_GRANTED");
								return result;
							} else {
								result->error = strdup("OPERATION_NOT_PERMITTED");
								return result;
							}
						}
					}
				}

				if(strcmp(argp->operation_type, "INSERT") == 0){
					for(int j = 0; j < usersIdDatabase.number_of_approvals_colums; j++){
						if(strcmp(argp->accessed_resource, usersIdDatabase.approvals[global_current_line_approvals][j].name) == 0){
							if(usersIdDatabase.approvals[global_current_line_approvals][j].insert == 1){
								result->error = strdup("PERMISSION_GRANTED");
								return result;
							} else {
								result->error = strdup("OPERATION_NOT_PERMITTED");
								return result;
							}
						}
					}
				}

				if(strcmp(argp->operation_type, "MODIFY") == 0){
					for(int j = 0; j < usersIdDatabase.number_of_approvals_colums; j++){
						if(strcmp(argp->accessed_resource, usersIdDatabase.approvals[global_current_line_approvals][j].name) == 0){
							if(usersIdDatabase.approvals[global_current_line_approvals][j].modify == 1){
								result->error = strdup("PERMISSION_GRANTED");
								return result;
							} else {
								result->error = strdup("OPERATION_NOT_PERMITTED");
								return result;
							}
						}
					}
				}

				if(strcmp(argp->operation_type, "DELETE") == 0){
					for(int j = 0; j < usersIdDatabase.number_of_approvals_colums; j++){
						if(strcmp(argp->accessed_resource, usersIdDatabase.approvals[global_current_line_approvals][j].name) == 0){
							if(usersIdDatabase.approvals[global_current_line_approvals][j].delete == 1){
								result->error = strdup("PERMISSION_GRANTED");
								return result;
							} else {
								result->error = strdup("OPERATION_NOT_PERMITTED");
								return result;
							}
						}
					}
				}

				if(strcmp(argp->operation_type, "EXECUTE") == 0){
					for(int j = 0; j < usersIdDatabase.number_of_approvals_colums; j++){
						if(strcmp(argp->accessed_resource, usersIdDatabase.approvals[global_current_line_approvals][j].name) == 0){
							if(usersIdDatabase.approvals[global_current_line_approvals][j].execute == 1){
								result->error = strdup("PERMISSION_GRANTED");
								return result;
							} else {
								result->error = strdup("OPERATION_NOT_PERMITTED");
								return result;
							}
						}
					}
				}


			}


		}
	}
	result->access_token = strdup("");
	result->refresh_token = strdup("");
	result->validation_time = -1;
	result->error = strdup("PERMISION_DENIED");

	/*
	 * insert server code here
	 */

	return result;
}

char **
approve_request_token_func_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	if(usersIdDatabase.approvals[global_current_line_approvals][0].name == NULL){
		global_current_line_approvals++;
		printf("================%s\n",*argp);
		result = strdup(*argp);
		return &result;
	}
	printf("================%s\n",*argp);
	char* signed_token = calloc(SIGNED_TOKEN_LEN, sizeof(char));
	strcpy(signed_token, *argp);
	strcat(signed_token, "CONFIRM");
	usersIdDatabase.signed_tokens_permisions = realloc(usersIdDatabase.signed_tokens_permisions, (usersIdDatabase.number_of_signed_tokens_permisions + 1) * sizeof(SignedTokenPermisions));
	usersIdDatabase.signed_tokens_permisions[usersIdDatabase.number_of_signed_tokens_permisions].token = signed_token;
	usersIdDatabase.signed_tokens_permisions[usersIdDatabase.number_of_signed_tokens_permisions].approvals = usersIdDatabase.approvals[global_current_line_approvals];
	usersIdDatabase.number_of_signed_tokens_permisions++;
	result = strdup(signed_token);
	global_current_line_approvals++;

	for(int i = 0; i < usersIdDatabase.number_of_signed_tokens_permisions; i++){
		printf("%d = %s\n",i,usersIdDatabase.signed_tokens_permisions[i].token);
	}
	return &result;
}
